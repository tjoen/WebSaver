(function (b) { var a = {}; if (typeof (exports) === "undefined") { if (typeof define == "function" && typeof define.amd == "object" && define.amd) { a.exports = {}; define(function () { return a.exports }) } else { a.exports = typeof (window) !== "undefined" ? window : b } } else { a.exports = exports } (function (j) { if (!o) { var o = 0.000001 } if (!e) { var e = (typeof Float32Array !== "undefined") ? Float32Array : Array } if (!i) { var i = Math.random } var f = {}; f.setMatrixArrayType = function (p) { e = p }; if (typeof (j) !== "undefined") { j.glMatrix = f } var m = {}; m.create = function () { var p = new e(2); p[0] = 0; p[1] = 0; return p }; m.clone = function (p) { var q = new e(2); q[0] = p[0]; q[1] = p[1]; return q }; m.fromValues = function (p, r) { var q = new e(2); q[0] = p; q[1] = r; return q }; m.copy = function (q, p) { q[0] = p[0]; q[1] = p[1]; return q }; m.set = function (q, p, r) { q[0] = p; q[1] = r; return q }; m.add = function (r, q, p) { r[0] = q[0] + p[0]; r[1] = q[1] + p[1]; return r }; m.subtract = function (r, q, p) { r[0] = q[0] - p[0]; r[1] = q[1] - p[1]; return r }; m.sub = m.subtract; m.multiply = function (r, q, p) { r[0] = q[0] * p[0]; r[1] = q[1] * p[1]; return r }; m.mul = m.multiply; m.divide = function (r, q, p) { r[0] = q[0] / p[0]; r[1] = q[1] / p[1]; return r }; m.div = m.divide; m.min = function (r, q, p) { r[0] = Math.min(q[0], p[0]); r[1] = Math.min(q[1], p[1]); return r }; m.max = function (r, q, p) { r[0] = Math.max(q[0], p[0]); r[1] = Math.max(q[1], p[1]); return r }; m.scale = function (r, q, p) { r[0] = q[0] * p; r[1] = q[1] * p; return r }; m.scaleAndAdd = function (r, q, p, s) { r[0] = q[0] + (p[0] * s); r[1] = q[1] + (p[1] * s); return r }; m.distance = function (r, q) { var p = q[0] - r[0], s = q[1] - r[1]; return Math.sqrt(p * p + s * s) }; m.dist = m.distance; m.squaredDistance = function (r, q) { var p = q[0] - r[0], s = q[1] - r[1]; return p * p + s * s }; m.sqrDist = m.squaredDistance; m.length = function (q) { var p = q[0], r = q[1]; return Math.sqrt(p * p + r * r) }; m.len = m.length; m.squaredLength = function (q) { var p = q[0], r = q[1]; return p * p + r * r }; m.sqrLen = m.squaredLength; m.negate = function (q, p) { q[0] = -p[0]; q[1] = -p[1]; return q }; m.normalize = function (s, r) { var q = r[0], t = r[1]; var p = q * q + t * t; if (p > 0) { p = 1 / Math.sqrt(p); s[0] = r[0] * p; s[1] = r[1] * p } return s }; m.dot = function (q, p) { return q[0] * p[0] + q[1] * p[1] }; m.cross = function (r, q, p) { var s = q[0] * p[1] - q[1] * p[0]; r[0] = r[1] = 0; r[2] = s; return r }; m.lerp = function (r, q, p, s) { var v = q[0], u = q[1]; r[0] = v + s * (p[0] - v); r[1] = u + s * (p[1] - u); return r }; m.random = function (p, s) { s = s || 1; var q = i() * 2 * Math.PI; p[0] = Math.cos(q) * s; p[1] = Math.sin(q) * s; return p }; m.transformMat2 = function (s, r, q) { var p = r[0], t = r[1]; s[0] = q[0] * p + q[2] * t; s[1] = q[1] * p + q[3] * t; return s }; m.transformMat2d = function (s, r, q) { var p = r[0], t = r[1]; s[0] = q[0] * p + q[2] * t + q[4]; s[1] = q[1] * p + q[3] * t + q[5]; return s }; m.transformMat3 = function (s, r, q) { var p = r[0], t = r[1]; s[0] = q[0] * p + q[3] * t + q[6]; s[1] = q[1] * p + q[4] * t + q[7]; return s }; m.transformMat4 = function (s, r, q) { var p = r[0], t = r[1]; s[0] = q[0] * p + q[4] * t + q[12]; s[1] = q[1] * p + q[5] * t + q[13]; return s }; m.forEach = (function () { var p = m.create(); return function (s, w, x, v, u, q) { var t, r; if (!w) { w = 2 } if (!x) { x = 0 } if (v) { r = Math.min((v * w) + x, s.length) } else { r = s.length } for (t = x; t < r; t += w) { p[0] = s[t]; p[1] = s[t + 1]; u(p, p, q); s[t] = p[0]; s[t + 1] = p[1] } return s } })(); m.str = function (p) { return "vec2(" + p[0] + ", " + p[1] + ")" }; if (typeof (j) !== "undefined") { j.vec2 = m } var l = {}; l.create = function () { var p = new e(3); p[0] = 0; p[1] = 0; p[2] = 0; return p }; l.clone = function (p) { var q = new e(3); q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; return q }; l.fromValues = function (p, s, r) { var q = new e(3); q[0] = p; q[1] = s; q[2] = r; return q }; l.copy = function (q, p) { q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; return q }; l.set = function (q, p, s, r) { q[0] = p; q[1] = s; q[2] = r; return q }; l.add = function (r, q, p) { r[0] = q[0] + p[0]; r[1] = q[1] + p[1]; r[2] = q[2] + p[2]; return r }; l.subtract = function (r, q, p) { r[0] = q[0] - p[0]; r[1] = q[1] - p[1]; r[2] = q[2] - p[2]; return r }; l.sub = l.subtract; l.multiply = function (r, q, p) { r[0] = q[0] * p[0]; r[1] = q[1] * p[1]; r[2] = q[2] * p[2]; return r }; l.mul = l.multiply; l.divide = function (r, q, p) { r[0] = q[0] / p[0]; r[1] = q[1] / p[1]; r[2] = q[2] / p[2]; return r }; l.div = l.divide; l.min = function (r, q, p) { r[0] = Math.min(q[0], p[0]); r[1] = Math.min(q[1], p[1]); r[2] = Math.min(q[2], p[2]); return r }; l.max = function (r, q, p) { r[0] = Math.max(q[0], p[0]); r[1] = Math.max(q[1], p[1]); r[2] = Math.max(q[2], p[2]); return r }; l.scale = function (r, q, p) { r[0] = q[0] * p; r[1] = q[1] * p; r[2] = q[2] * p; return r }; l.scaleAndAdd = function (r, q, p, s) { r[0] = q[0] + (p[0] * s); r[1] = q[1] + (p[1] * s); r[2] = q[2] + (p[2] * s); return r }; l.distance = function (r, q) { var p = q[0] - r[0], t = q[1] - r[1], s = q[2] - r[2]; return Math.sqrt(p * p + t * t + s * s) }; l.dist = l.distance; l.squaredDistance = function (r, q) { var p = q[0] - r[0], t = q[1] - r[1], s = q[2] - r[2]; return p * p + t * t + s * s }; l.sqrDist = l.squaredDistance; l.length = function (q) { var p = q[0], s = q[1], r = q[2]; return Math.sqrt(p * p + s * s + r * r) }; l.len = l.length; l.squaredLength = function (q) { var p = q[0], s = q[1], r = q[2]; return p * p + s * s + r * r }; l.sqrLen = l.squaredLength; l.negate = function (q, p) { q[0] = -p[0]; q[1] = -p[1]; q[2] = -p[2]; return q }; l.normalize = function (s, r) { var q = r[0], u = r[1], t = r[2]; var p = q * q + u * u + t * t; if (p > 0) { p = 1 / Math.sqrt(p); s[0] = r[0] * p; s[1] = r[1] * p; s[2] = r[2] * p } return s }; l.dot = function (q, p) { return q[0] * p[0] + q[1] * p[1] + q[2] * p[2] }; l.cross = function (q, v, u) { var p = v[0], x = v[1], w = v[2], t = u[0], s = u[1], r = u[2]; q[0] = x * r - w * s; q[1] = w * t - p * r; q[2] = p * s - x * t; return q }; l.lerp = function (r, q, p, s) { var w = q[0], v = q[1], u = q[2]; r[0] = w + s * (p[0] - w); r[1] = v + s * (p[1] - v); r[2] = u + s * (p[2] - u); return r }; l.random = function (p, u) { u = u || 1; var s = i() * 2 * Math.PI; var t = (i() * 2) - 1; var q = Math.sqrt(1 - t * t) * u; p[0] = Math.cos(s) * q; p[1] = Math.sin(s) * q; p[2] = t * u; return p }; l.transformMat4 = function (s, r, q) { var p = r[0], u = r[1], t = r[2]; s[0] = q[0] * p + q[4] * u + q[8] * t + q[12]; s[1] = q[1] * p + q[5] * u + q[9] * t + q[13]; s[2] = q[2] * p + q[6] * u + q[10] * t + q[14]; return s }; l.transformMat3 = function (s, r, q) { var p = r[0], u = r[1], t = r[2]; s[0] = p * q[0] + u * q[3] + t * q[6]; s[1] = p * q[1] + u * q[4] + t * q[7]; s[2] = p * q[2] + u * q[5] + t * q[8]; return s }; l.transformQuat = function (w, F, p) { var G = F[0], E = F[1], D = F[2], B = p[0], A = p[1], v = p[2], C = p[3], t = C * G + A * D - v * E, s = C * E + v * G - B * D, r = C * D + B * E - A * G, u = -B * G - A * E - v * D; w[0] = t * C + u * -B + s * -v - r * -A; w[1] = s * C + u * -A + r * -B - t * -v; w[2] = r * C + u * -v + t * -A - s * -B; return w }; l.forEach = (function () { var p = l.create(); return function (s, w, x, v, u, q) { var t, r; if (!w) { w = 3 } if (!x) { x = 0 } if (v) { r = Math.min((v * w) + x, s.length) } else { r = s.length } for (t = x; t < r; t += w) { p[0] = s[t]; p[1] = s[t + 1]; p[2] = s[t + 2]; u(p, p, q); s[t] = p[0]; s[t + 1] = p[1]; s[t + 2] = p[2] } return s } })(); l.str = function (p) { return "vec3(" + p[0] + ", " + p[1] + ", " + p[2] + ")" }; if (typeof (j) !== "undefined") { j.vec3 = l } var k = {}; k.create = function () { var p = new e(4); p[0] = 0; p[1] = 0; p[2] = 0; p[3] = 0; return p }; k.clone = function (p) { var q = new e(4); q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3]; return q }; k.fromValues = function (p, t, s, q) { var r = new e(4); r[0] = p; r[1] = t; r[2] = s; r[3] = q; return r }; k.copy = function (q, p) { q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3]; return q }; k.set = function (r, p, t, s, q) { r[0] = p; r[1] = t; r[2] = s; r[3] = q; return r }; k.add = function (r, q, p) { r[0] = q[0] + p[0]; r[1] = q[1] + p[1]; r[2] = q[2] + p[2]; r[3] = q[3] + p[3]; return r }; k.subtract = function (r, q, p) { r[0] = q[0] - p[0]; r[1] = q[1] - p[1]; r[2] = q[2] - p[2]; r[3] = q[3] - p[3]; return r }; k.sub = k.subtract; k.multiply = function (r, q, p) { r[0] = q[0] * p[0]; r[1] = q[1] * p[1]; r[2] = q[2] * p[2]; r[3] = q[3] * p[3]; return r }; k.mul = k.multiply; k.divide = function (r, q, p) { r[0] = q[0] / p[0]; r[1] = q[1] / p[1]; r[2] = q[2] / p[2]; r[3] = q[3] / p[3]; return r }; k.div = k.divide; k.min = function (r, q, p) { r[0] = Math.min(q[0], p[0]); r[1] = Math.min(q[1], p[1]); r[2] = Math.min(q[2], p[2]); r[3] = Math.min(q[3], p[3]); return r }; k.max = function (r, q, p) { r[0] = Math.max(q[0], p[0]); r[1] = Math.max(q[1], p[1]); r[2] = Math.max(q[2], p[2]); r[3] = Math.max(q[3], p[3]); return r }; k.scale = function (r, q, p) { r[0] = q[0] * p; r[1] = q[1] * p; r[2] = q[2] * p; r[3] = q[3] * p; return r }; k.scaleAndAdd = function (r, q, p, s) { r[0] = q[0] + (p[0] * s); r[1] = q[1] + (p[1] * s); r[2] = q[2] + (p[2] * s); r[3] = q[3] + (p[3] * s); return r }; k.distance = function (s, q) { var p = q[0] - s[0], u = q[1] - s[1], t = q[2] - s[2], r = q[3] - s[3]; return Math.sqrt(p * p + u * u + t * t + r * r) }; k.dist = k.distance; k.squaredDistance = function (s, q) { var p = q[0] - s[0], u = q[1] - s[1], t = q[2] - s[2], r = q[3] - s[3]; return p * p + u * u + t * t + r * r }; k.sqrDist = k.squaredDistance; k.length = function (r) { var p = r[0], t = r[1], s = r[2], q = r[3]; return Math.sqrt(p * p + t * t + s * s + q * q) }; k.len = k.length; k.squaredLength = function (r) { var p = r[0], t = r[1], s = r[2], q = r[3]; return p * p + t * t + s * s + q * q }; k.sqrLen = k.squaredLength; k.negate = function (q, p) { q[0] = -p[0]; q[1] = -p[1]; q[2] = -p[2]; q[3] = -p[3]; return q }; k.normalize = function (t, s) { var q = s[0], v = s[1], u = s[2], r = s[3]; var p = q * q + v * v + u * u + r * r; if (p > 0) { p = 1 / Math.sqrt(p); t[0] = s[0] * p; t[1] = s[1] * p; t[2] = s[2] * p; t[3] = s[3] * p } return t }; k.dot = function (q, p) { return q[0] * p[0] + q[1] * p[1] + q[2] * p[2] + q[3] * p[3] }; k.lerp = function (r, q, p, s) { var w = q[0], v = q[1], u = q[2], x = q[3]; r[0] = w + s * (p[0] - w); r[1] = v + s * (p[1] - v); r[2] = u + s * (p[2] - u); r[3] = x + s * (p[3] - x); return r }; k.random = function (p, q) { q = q || 1; p[0] = i(); p[1] = i(); p[2] = i(); p[3] = i(); k.normalize(p, p); k.scale(p, p, q); return p }; k.transformMat4 = function (t, s, q) { var p = s[0], v = s[1], u = s[2], r = s[3]; t[0] = q[0] * p + q[4] * v + q[8] * u + q[12] * r; t[1] = q[1] * p + q[5] * v + q[9] * u + q[13] * r; t[2] = q[2] * p + q[6] * v + q[10] * u + q[14] * r; t[3] = q[3] * p + q[7] * v + q[11] * u + q[15] * r; return t }; k.transformQuat = function (w, F, p) { var G = F[0], E = F[1], D = F[2], B = p[0], A = p[1], v = p[2], C = p[3], t = C * G + A * D - v * E, s = C * E + v * G - B * D, r = C * D + B * E - A * G, u = -B * G - A * E - v * D; w[0] = t * C + u * -B + s * -v - r * -A; w[1] = s * C + u * -A + r * -B - t * -v; w[2] = r * C + u * -v + t * -A - s * -B; return w }; k.forEach = (function () { var p = k.create(); return function (s, w, x, v, u, q) { var t, r; if (!w) { w = 4 } if (!x) { x = 0 } if (v) { r = Math.min((v * w) + x, s.length) } else { r = s.length } for (t = x; t < r; t += w) { p[0] = s[t]; p[1] = s[t + 1]; p[2] = s[t + 2]; p[3] = s[t + 3]; u(p, p, q); s[t] = p[0]; s[t + 1] = p[1]; s[t + 2] = p[2]; s[t + 3] = p[3] } return s } })(); k.str = function (p) { return "vec4(" + p[0] + ", " + p[1] + ", " + p[2] + ", " + p[3] + ")" }; if (typeof (j) !== "undefined") { j.vec4 = k } var g = {}; g.create = function () { var p = new e(4); p[0] = 1; p[1] = 0; p[2] = 0; p[3] = 1; return p }; g.clone = function (p) { var q = new e(4); q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3]; return q }; g.copy = function (q, p) { q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3]; return q }; g.identity = function (p) { p[0] = 1; p[1] = 0; p[2] = 0; p[3] = 1; return p }; g.transpose = function (r, q) { if (r === q) { var p = q[1]; r[1] = q[2]; r[2] = p } else { r[0] = q[0]; r[1] = q[2]; r[2] = q[1]; r[3] = q[3] } return r }; g.invert = function (t, r) { var s = r[0], q = r[1], p = r[2], v = r[3], u = s * v - p * q; if (!u) { return null } u = 1 / u; t[0] = v * u; t[1] = -q * u; t[2] = -p * u; t[3] = s * u; return t }; g.adjoint = function (r, p) { var q = p[0]; r[0] = p[3]; r[1] = -p[1]; r[2] = -p[2]; r[3] = q; return r }; g.determinant = function (p) { return p[0] * p[3] - p[2] * p[1] }; g.multiply = function (t, y, w) { var s = y[0], r = y[1], q = y[2], p = y[3]; var z = w[0], x = w[1], v = w[2], u = w[3]; t[0] = s * z + r * v; t[1] = s * x + r * u; t[2] = q * z + p * v; t[3] = q * x + p * u; return t }; g.mul = g.multiply; g.rotate = function (u, x, w) { var t = x[0], r = x[1], q = x[2], p = x[3], y = Math.sin(w), v = Math.cos(w); u[0] = t * v + r * y; u[1] = t * -y + r * v; u[2] = q * v + p * y; u[3] = q * -y + p * v; return u }; g.scale = function (t, u, x) { var s = u[0], r = u[1], q = u[2], p = u[3], y = x[0], w = x[1]; t[0] = s * y; t[1] = r * w; t[2] = q * y; t[3] = p * w; return t }; g.str = function (p) { return "mat2(" + p[0] + ", " + p[1] + ", " + p[2] + ", " + p[3] + ")" }; if (typeof (j) !== "undefined") { j.mat2 = g } var n = {}; n.create = function () { var p = new e(6); p[0] = 1; p[1] = 0; p[2] = 0; p[3] = 1; p[4] = 0; p[5] = 0; return p }; n.clone = function (p) { var q = new e(6); q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3]; q[4] = p[4]; q[5] = p[5]; return q }; n.copy = function (q, p) { q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3]; q[4] = p[4]; q[5] = p[5]; return q }; n.identity = function (p) { p[0] = 1; p[1] = 0; p[2] = 0; p[3] = 1; p[4] = 0; p[5] = 0; return p }; n.invert = function (q, u) { var p = u[0], x = u[1], w = u[2], v = u[3], s = u[4], r = u[5]; var t = p * v - x * w; if (!t) { return null } t = 1 / t; q[0] = v * t; q[1] = -x * t; q[2] = -w * t; q[3] = p * t; q[4] = (w * r - v * s) * t; q[5] = (x * s - p * r) * t; return q }; n.determinant = function (p) { return p[0] * p[3] - p[1] * p[2] }; n.multiply = function (q, A, z) { var p = A[0], D = A[1], C = A[2], B = A[3], s = A[4], r = A[5], x = z[0], v = z[1], u = z[2], t = z[3], y = z[4], w = z[5]; q[0] = p * x + D * u; q[1] = p * v + D * t; q[2] = C * x + B * u; q[3] = C * v + B * t; q[4] = x * s + u * r + y; q[5] = v * s + t * r + w; return q }; n.mul = n.multiply; n.rotate = function (q, v, u) { var p = v[0], z = v[1], y = v[2], w = v[3], t = v[4], r = v[5], x = Math.sin(u), s = Math.cos(u); q[0] = p * s + z * x; q[1] = -p * x + z * s; q[2] = y * s + w * x; q[3] = -y * x + s * w; q[4] = s * t + x * r; q[5] = s * r - x * t; return q }; n.scale = function (r, p, q) { var t = q[0], s = q[1]; r[0] = p[0] * t; r[1] = p[1] * s; r[2] = p[2] * t; r[3] = p[3] * s; r[4] = p[4] * t; r[5] = p[5] * s; return r }; n.translate = function (r, p, q) { r[0] = p[0]; r[1] = p[1]; r[2] = p[2]; r[3] = p[3]; r[4] = p[4] + q[0]; r[5] = p[5] + q[1]; return r }; n.str = function (p) { return "mat2d(" + p[0] + ", " + p[1] + ", " + p[2] + ", " + p[3] + ", " + p[4] + ", " + p[5] + ")" }; if (typeof (j) !== "undefined") { j.mat2d = n } var d = {}; d.create = function () { var p = new e(9); p[0] = 1; p[1] = 0; p[2] = 0; p[3] = 0; p[4] = 1; p[5] = 0; p[6] = 0; p[7] = 0; p[8] = 1; return p }; d.fromMat4 = function (q, p) { q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[4]; q[4] = p[5]; q[5] = p[6]; q[6] = p[8]; q[7] = p[9]; q[8] = p[10]; return q }; d.clone = function (p) { var q = new e(9); q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3]; q[4] = p[4]; q[5] = p[5]; q[6] = p[6]; q[7] = p[7]; q[8] = p[8]; return q }; d.copy = function (q, p) { q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3]; q[4] = p[4]; q[5] = p[5]; q[6] = p[6]; q[7] = p[7]; q[8] = p[8]; return q }; d.identity = function (p) { p[0] = 1; p[1] = 0; p[2] = 0; p[3] = 0; p[4] = 1; p[5] = 0; p[6] = 0; p[7] = 0; p[8] = 1; return p }; d.transpose = function (r, q) { if (r === q) { var t = q[1], s = q[2], p = q[5]; r[1] = q[3]; r[2] = q[6]; r[3] = t; r[5] = q[7]; r[6] = s; r[7] = p } else { r[0] = q[0]; r[1] = q[3]; r[2] = q[6]; r[3] = q[1]; r[4] = q[4]; r[5] = q[7]; r[6] = q[2]; r[7] = q[5]; r[8] = q[8] } return r }; d.invert = function (t, A) { var s = A[0], r = A[1], q = A[2], D = A[3], C = A[4], B = A[5], y = A[6], x = A[7], v = A[8], u = v * C - B * x, p = -v * D + B * y, z = x * D - C * y, w = s * u + r * p + q * z; if (!w) { return null } w = 1 / w; t[0] = u * w; t[1] = (-v * r + q * x) * w; t[2] = (B * r - q * C) * w; t[3] = p * w; t[4] = (v * s - q * y) * w; t[5] = (-B * s + q * D) * w; t[6] = z * w; t[7] = (-x * s + r * y) * w; t[8] = (C * s - r * D) * w; return t }; d.adjoint = function (s, w) { var r = w[0], q = w[1], p = w[2], z = w[3], y = w[4], x = w[5], v = w[6], u = w[7], t = w[8]; s[0] = (y * t - x * u); s[1] = (p * u - q * t); s[2] = (q * x - p * y); s[3] = (x * v - z * t); s[4] = (r * t - p * v); s[5] = (p * z - r * x); s[6] = (z * u - y * v); s[7] = (q * v - r * u); s[8] = (r * y - q * z); return s }; d.determinant = function (v) { var r = v[0], q = v[1], p = v[2], y = v[3], x = v[4], w = v[5], u = v[6], t = v[7], s = v[8]; return r * (s * x - w * t) + q * (-s * y + w * u) + p * (t * y - x * u) }; d.multiply = function (B, G, F) { var J = G[0], I = G[1], H = G[2], u = G[3], t = G[4], s = G[5], A = G[6], z = G[7], y = G[8], x = F[0], w = F[1], v = F[2], E = F[3], D = F[4], C = F[5], r = F[6], q = F[7], p = F[8]; B[0] = x * J + w * u + v * A; B[1] = x * I + w * t + v * z; B[2] = x * H + w * s + v * y; B[3] = E * J + D * u + C * A; B[4] = E * I + D * t + C * z; B[5] = E * H + D * s + C * y; B[6] = r * J + q * u + p * A; B[7] = r * I + q * t + p * z; B[8] = r * H + q * s + p * y; return B }; d.mul = d.multiply; d.translate = function (s, B, D) { var r = B[0], q = B[1], p = B[2], F = B[3], E = B[4], C = B[5], w = B[6], u = B[7], t = B[8], A = D[0], z = D[1]; s[0] = r; s[1] = q; s[2] = p; s[3] = F; s[4] = E; s[5] = C; s[6] = A * r + z * F + w; s[7] = A * q + z * E + u; s[8] = A * p + z * C + t; return s }; d.rotate = function (t, z, y) { var r = z[0], q = z[1], p = z[2], C = z[3], B = z[4], A = z[5], w = z[6], v = z[7], u = z[8], D = Math.sin(y), x = Math.cos(y); t[0] = x * r + D * C; t[1] = x * q + D * B; t[2] = x * p + D * A; t[3] = x * C - D * r; t[4] = x * B - D * q; t[5] = x * A - D * p; t[6] = w; t[7] = v; t[8] = u; return t }; d.scale = function (s, q, r) { var p = r[0], t = r[1]; s[0] = p * q[0]; s[1] = p * q[1]; s[2] = p * q[2]; s[3] = t * q[3]; s[4] = t * q[4]; s[5] = t * q[5]; s[6] = q[6]; s[7] = q[7]; s[8] = q[8]; return s }; d.fromMat2d = function (q, p) { q[0] = p[0]; q[1] = p[1]; q[2] = 0; q[3] = p[2]; q[4] = p[3]; q[5] = 0; q[6] = p[4]; q[7] = p[5]; q[8] = 1; return q }; d.fromQuat = function (G, E) { var A = E[0], v = E[1], u = E[2], B = E[3], H = A + A, p = v + v, C = u + u, t = A * H, s = A * p, r = A * C, F = v * p, D = v * C, K = u * C, L = B * H, J = B * p, I = B * C; G[0] = 1 - (F + K); G[3] = s + I; G[6] = r - J; G[1] = s - I; G[4] = 1 - (t + K); G[7] = D + L; G[2] = r + J; G[5] = D - L; G[8] = 1 - (t + F); return G }; d.normalFromMat4 = function (I, N) { var R = N[0], P = N[1], O = N[2], L = N[3], t = N[4], s = N[5], r = N[6], q = N[7], H = N[8], G = N[9], F = N[10], E = N[11], T = N[12], S = N[13], Q = N[14], M = N[15], D = R * s - P * t, C = R * r - O * t, B = R * q - L * t, A = P * r - O * s, z = P * q - L * s, y = O * q - L * r, x = H * S - G * T, w = H * Q - F * T, v = H * M - E * T, u = G * Q - F * S, K = G * M - E * S, J = F * M - E * Q, p = D * J - C * K + B * u + A * v - z * w + y * x; if (!p) { return null } p = 1 / p; I[0] = (s * J - r * K + q * u) * p; I[1] = (r * v - t * J - q * w) * p; I[2] = (t * K - s * v + q * x) * p; I[3] = (O * K - P * J - L * u) * p; I[4] = (R * J - O * v + L * w) * p; I[5] = (P * v - R * K - L * x) * p; I[6] = (S * y - Q * z + M * A) * p; I[7] = (Q * B - T * y - M * C) * p; I[8] = (T * z - S * B + M * D) * p; return I }; d.str = function (p) { return "mat3(" + p[0] + ", " + p[1] + ", " + p[2] + ", " + p[3] + ", " + p[4] + ", " + p[5] + ", " + p[6] + ", " + p[7] + ", " + p[8] + ")" }; if (typeof (j) !== "undefined") { j.mat3 = d } var c = {}; c.create = function () { var p = new e(16); p[0] = 1; p[1] = 0; p[2] = 0; p[3] = 0; p[4] = 0; p[5] = 1; p[6] = 0; p[7] = 0; p[8] = 0; p[9] = 0; p[10] = 1; p[11] = 0; p[12] = 0; p[13] = 0; p[14] = 0; p[15] = 1; return p }; c.clone = function (p) { var q = new e(16); q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3]; q[4] = p[4]; q[5] = p[5]; q[6] = p[6]; q[7] = p[7]; q[8] = p[8]; q[9] = p[9]; q[10] = p[10]; q[11] = p[11]; q[12] = p[12]; q[13] = p[13]; q[14] = p[14]; q[15] = p[15]; return q }; c.copy = function (q, p) { q[0] = p[0]; q[1] = p[1]; q[2] = p[2]; q[3] = p[3]; q[4] = p[4]; q[5] = p[5]; q[6] = p[6]; q[7] = p[7]; q[8] = p[8]; q[9] = p[9]; q[10] = p[10]; q[11] = p[11]; q[12] = p[12]; q[13] = p[13]; q[14] = p[14]; q[15] = p[15]; return q }; c.identity = function (p) { p[0] = 1; p[1] = 0; p[2] = 0; p[3] = 0; p[4] = 0; p[5] = 1; p[6] = 0; p[7] = 0; p[8] = 0; p[9] = 0; p[10] = 1; p[11] = 0; p[12] = 0; p[13] = 0; p[14] = 0; p[15] = 1; return p }; c.transpose = function (s, r) { if (s === r) { var w = r[1], u = r[2], t = r[3], p = r[6], v = r[7], q = r[11]; s[1] = r[4]; s[2] = r[8]; s[3] = r[12]; s[4] = w; s[6] = r[9]; s[7] = r[13]; s[8] = u; s[9] = p; s[11] = r[14]; s[12] = t; s[13] = v; s[14] = q } else { s[0] = r[0]; s[1] = r[4]; s[2] = r[8]; s[3] = r[12]; s[4] = r[1]; s[5] = r[5]; s[6] = r[9]; s[7] = r[13]; s[8] = r[2]; s[9] = r[6]; s[10] = r[10]; s[11] = r[14]; s[12] = r[3]; s[13] = r[7]; s[14] = r[11]; s[15] = r[15] } return s }; c.invert = function (I, N) { var R = N[0], P = N[1], O = N[2], L = N[3], t = N[4], s = N[5], r = N[6], q = N[7], H = N[8], G = N[9], F = N[10], E = N[11], T = N[12], S = N[13], Q = N[14], M = N[15], D = R * s - P * t, C = R * r - O * t, B = R * q - L * t, A = P * r - O * s, z = P * q - L * s, y = O * q - L * r, x = H * S - G * T, w = H * Q - F * T, v = H * M - E * T, u = G * Q - F * S, K = G * M - E * S, J = F * M - E * Q, p = D * J - C * K + B * u + A * v - z * w + y * x; if (!p) { return null } p = 1 / p; I[0] = (s * J - r * K + q * u) * p; I[1] = (O * K - P * J - L * u) * p; I[2] = (S * y - Q * z + M * A) * p; I[3] = (F * z - G * y - E * A) * p; I[4] = (r * v - t * J - q * w) * p; I[5] = (R * J - O * v + L * w) * p; I[6] = (Q * B - T * y - M * C) * p; I[7] = (H * y - F * B + E * C) * p; I[8] = (t * K - s * v + q * x) * p; I[9] = (P * v - R * K - L * x) * p; I[10] = (T * z - S * B + M * D) * p; I[11] = (G * B - H * z - E * D) * p; I[12] = (s * w - t * u - r * x) * p; I[13] = (R * u - P * w + O * x) * p; I[14] = (S * C - T * A - Q * D) * p; I[15] = (H * A - G * C + F * D) * p; return I }; c.adjoint = function (x, A) { var E = A[0], C = A[1], B = A[2], y = A[3], s = A[4], r = A[5], q = A[6], p = A[7], w = A[8], v = A[9], u = A[10], t = A[11], G = A[12], F = A[13], D = A[14], z = A[15]; x[0] = (r * (u * z - t * D) - v * (q * z - p * D) + F * (q * t - p * u)); x[1] = -(C * (u * z - t * D) - v * (B * z - y * D) + F * (B * t - y * u)); x[2] = (C * (q * z - p * D) - r * (B * z - y * D) + F * (B * p - y * q)); x[3] = -(C * (q * t - p * u) - r * (B * t - y * u) + v * (B * p - y * q)); x[4] = -(s * (u * z - t * D) - w * (q * z - p * D) + G * (q * t - p * u)); x[5] = (E * (u * z - t * D) - w * (B * z - y * D) + G * (B * t - y * u)); x[6] = -(E * (q * z - p * D) - s * (B * z - y * D) + G * (B * p - y * q)); x[7] = (E * (q * t - p * u) - s * (B * t - y * u) + w * (B * p - y * q)); x[8] = (s * (v * z - t * F) - w * (r * z - p * F) + G * (r * t - p * v)); x[9] = -(E * (v * z - t * F) - w * (C * z - y * F) + G * (C * t - y * v)); x[10] = (E * (r * z - p * F) - s * (C * z - y * F) + G * (C * p - y * r)); x[11] = -(E * (r * t - p * v) - s * (C * t - y * v) + w * (C * p - y * r)); x[12] = -(s * (v * D - u * F) - w * (r * D - q * F) + G * (r * u - q * v)); x[13] = (E * (v * D - u * F) - w * (C * D - B * F) + G * (C * u - B * v)); x[14] = -(E * (r * D - q * F) - s * (C * D - B * F) + G * (C * q - B * r)); x[15] = (E * (r * u - q * v) - s * (C * u - B * v) + w * (C * q - B * r)); return x }; c.determinant = function (K) { var P = K[0], N = K[1], L = K[2], J = K[3], s = K[4], r = K[5], q = K[6], p = K[7], G = K[8], F = K[9], E = K[10], D = K[11], R = K[12], Q = K[13], O = K[14], M = K[15], C = P * r - N * s, B = P * q - L * s, A = P * p - J * s, z = N * q - L * r, y = N * p - J * r, x = L * p - J * q, w = G * Q - F * R, v = G * O - E * R, u = G * M - D * R, t = F * O - E * Q, I = F * M - D * Q, H = E * M - D * O; return C * H - B * I + A * t + z * u - y * v + x * w }; c.multiply = function (B, F, C) { var J = F[0], I = F[1], G = F[2], D = F[3], v = F[4], t = F[5], r = F[6], p = F[7], A = F[8], z = F[9], y = F[10], x = F[11], L = F[12], K = F[13], H = F[14], E = F[15]; var w = C[0], u = C[1], s = C[2], q = C[3]; B[0] = w * J + u * v + s * A + q * L; B[1] = w * I + u * t + s * z + q * K; B[2] = w * G + u * r + s * y + q * H; B[3] = w * D + u * p + s * x + q * E; w = C[4]; u = C[5]; s = C[6]; q = C[7]; B[4] = w * J + u * v + s * A + q * L; B[5] = w * I + u * t + s * z + q * K; B[6] = w * G + u * r + s * y + q * H; B[7] = w * D + u * p + s * x + q * E; w = C[8]; u = C[9]; s = C[10]; q = C[11]; B[8] = w * J + u * v + s * A + q * L; B[9] = w * I + u * t + s * z + q * K; B[10] = w * G + u * r + s * y + q * H; B[11] = w * D + u * p + s * x + q * E; w = C[12]; u = C[13]; s = C[14]; q = C[15]; B[12] = w * J + u * v + s * A + q * L; B[13] = w * I + u * t + s * z + q * K; B[14] = w * G + u * r + s * y + q * H; B[15] = w * D + u * p + s * x + q * E; return B }; c.mul = c.multiply; c.translate = function (F, H, A) { var w = A[0], u = A[1], t = A[2], K, J, I, G, s, r, q, p, E, D, C, B; if (H === F) { F[12] = H[0] * w + H[4] * u + H[8] * t + H[12]; F[13] = H[1] * w + H[5] * u + H[9] * t + H[13]; F[14] = H[2] * w + H[6] * u + H[10] * t + H[14]; F[15] = H[3] * w + H[7] * u + H[11] * t + H[15] } else { K = H[0]; J = H[1]; I = H[2]; G = H[3]; s = H[4]; r = H[5]; q = H[6]; p = H[7]; E = H[8]; D = H[9]; C = H[10]; B = H[11]; F[0] = K; F[1] = J; F[2] = I; F[3] = G; F[4] = s; F[5] = r; F[6] = q; F[7] = p; F[8] = E; F[9] = D; F[10] = C; F[11] = B; F[12] = K * w + s * u + E * t + H[12]; F[13] = J * w + r * u + D * t + H[13]; F[14] = I * w + q * u + C * t + H[14]; F[15] = G * w + p * u + B * t + H[15] } return F }; c.scale = function (s, q, r) { var p = r[0], u = r[1], t = r[2]; s[0] = q[0] * p; s[1] = q[1] * p; s[2] = q[2] * p; s[3] = q[3] * p; s[4] = q[4] * u; s[5] = q[5] * u; s[6] = q[6] * u; s[7] = q[7] * u; s[8] = q[8] * t; s[9] = q[9] * t; s[10] = q[10] * t; s[11] = q[11] * t; s[12] = q[12]; s[13] = q[13]; s[14] = q[14]; s[15] = q[15]; return s }; c.rotate = function (O, V, X, p) { var E = p[0], D = p[1], C = p[2], P = Math.sqrt(E * E + D * D + C * C), J, T, I, Z, Y, W, U, B, A, w, v, N, M, L, K, H, G, F, S, R, Q, u, r, q; if (Math.abs(P) < o) { return null } P = 1 / P; E *= P; D *= P; C *= P; J = Math.sin(X); T = Math.cos(X); I = 1 - T; Z = V[0]; Y = V[1]; W = V[2]; U = V[3]; B = V[4]; A = V[5]; w = V[6]; v = V[7]; N = V[8]; M = V[9]; L = V[10]; K = V[11]; H = E * E * I + T; G = D * E * I + C * J; F = C * E * I - D * J; S = E * D * I - C * J; R = D * D * I + T; Q = C * D * I + E * J; u = E * C * I + D * J; r = D * C * I - E * J; q = C * C * I + T; O[0] = Z * H + B * G + N * F; O[1] = Y * H + A * G + M * F; O[2] = W * H + w * G + L * F; O[3] = U * H + v * G + K * F; O[4] = Z * S + B * R + N * Q; O[5] = Y * S + A * R + M * Q; O[6] = W * S + w * R + L * Q; O[7] = U * S + v * R + K * Q; O[8] = Z * u + B * r + N * q; O[9] = Y * u + A * r + M * q; O[10] = W * u + w * r + L * q; O[11] = U * u + v * r + K * q; if (V !== O) { O[12] = V[12]; O[13] = V[13]; O[14] = V[14]; O[15] = V[15] } return O }; c.rotateX = function (p, x, w) { var C = Math.sin(w), v = Math.cos(w), B = x[4], A = x[5], z = x[6], y = x[7], u = x[8], t = x[9], r = x[10], q = x[11]; if (x !== p) { p[0] = x[0]; p[1] = x[1]; p[2] = x[2]; p[3] = x[3]; p[12] = x[12]; p[13] = x[13]; p[14] = x[14]; p[15] = x[15] } p[4] = B * v + u * C; p[5] = A * v + t * C; p[6] = z * v + r * C; p[7] = y * v + q * C; p[8] = u * v - B * C; p[9] = t * v - A * C; p[10] = r * v - z * C; p[11] = q * v - y * C; return p }; c.rotateY = function (u, B, A) { var C = Math.sin(A), z = Math.cos(A), t = B[0], r = B[1], q = B[2], p = B[3], y = B[8], x = B[9], w = B[10], v = B[11]; if (B !== u) { u[4] = B[4]; u[5] = B[5]; u[6] = B[6]; u[7] = B[7]; u[12] = B[12]; u[13] = B[13]; u[14] = B[14]; u[15] = B[15] } u[0] = t * z - y * C; u[1] = r * z - x * C; u[2] = q * z - w * C; u[3] = p * z - v * C; u[8] = t * C + y * z; u[9] = r * C + x * z; u[10] = q * C + w * z; u[11] = p * C + v * z; return u }; c.rotateZ = function (u, x, w) { var C = Math.sin(w), v = Math.cos(w), t = x[0], r = x[1], q = x[2], p = x[3], B = x[4], A = x[5], z = x[6], y = x[7]; if (x !== u) { u[8] = x[8]; u[9] = x[9]; u[10] = x[10]; u[11] = x[11]; u[12] = x[12]; u[13] = x[13]; u[14] = x[14]; u[15] = x[15] } u[0] = t * v + B * C; u[1] = r * v + A * C; u[2] = q * v + z * C; u[3] = p * v + y * C; u[4] = B * v - t * C; u[5] = A * v - r * C; u[6] = z * v - q * C; u[7] = y * v - p * C; return u }; c.fromRotationTranslation = function (I, G, E) { var B = G[0], A = G[1], u = G[2], C = G[3], J = B + B, p = A + A, D = u + u, t = B * J, s = B * p, r = B * D, H = A * p, F = A * D, M = u * D, N = C * J, L = C * p, K = C * D; I[0] = 1 - (H + M); I[1] = s + K; I[2] = r - L; I[3] = 0; I[4] = s - K; I[5] = 1 - (t + M); I[6] = F + N; I[7] = 0; I[8] = r + L; I[9] = F - N; I[10] = 1 - (t + H); I[11] = 0; I[12] = E[0]; I[13] = E[1]; I[14] = E[2]; I[15] = 1; return I }; c.fromQuat = function (G, E) { var A = E[0], v = E[1], u = E[2], B = E[3], H = A + A, p = v + v, C = u + u, t = A * H, s = A * p, r = A * C, F = v * p, D = v * C, K = u * C, L = B * H, J = B * p, I = B * C; G[0] = 1 - (F + K); G[1] = s + I; G[2] = r - J; G[3] = 0; G[4] = s - I; G[5] = 1 - (t + K); G[6] = D + L; G[7] = 0; G[8] = r + J; G[9] = D - L; G[10] = 1 - (t + F); G[11] = 0; G[12] = 0; G[13] = 0; G[14] = 0; G[15] = 1; return G }; c.frustum = function (t, q, y, p, x, v, u) { var w = 1 / (y - q), s = 1 / (x - p), r = 1 / (v - u); t[0] = (v * 2) * w; t[1] = 0; t[2] = 0; t[3] = 0; t[4] = 0; t[5] = (v * 2) * s; t[6] = 0; t[7] = 0; t[8] = (y + q) * w; t[9] = (x + p) * s; t[10] = (u + v) * r; t[11] = -1; t[12] = 0; t[13] = 0; t[14] = (u * v * 2) * r; t[15] = 0; return t }; c.perspective = function (s, r, q, t, p) { var v = 1 / Math.tan(r / 2), u = 1 / (t - p); s[0] = v / q; s[1] = 0; s[2] = 0; s[3] = 0; s[4] = 0; s[5] = v; s[6] = 0; s[7] = 0; s[8] = 0; s[9] = 0; s[10] = (p + t) * u; s[11] = -1; s[12] = 0; s[13] = 0; s[14] = (2 * p * t) * u; s[15] = 0; return s }; c.ortho = function (s, q, y, p, w, v, u) { var t = 1 / (q - y), x = 1 / (p - w), r = 1 / (v - u); s[0] = -2 * t; s[1] = 0; s[2] = 0; s[3] = 0; s[4] = 0; s[5] = -2 * x; s[6] = 0; s[7] = 0; s[8] = 0; s[9] = 0; s[10] = 2 * r; s[11] = 0; s[12] = (q + y) * t; s[13] = (w + p) * x; s[14] = (u + v) * r; s[15] = 1; return s }; c.lookAt = function (D, K, L, v) { var J, I, G, r, q, p, y, x, w, E, H = K[0], F = K[1], C = K[2], u = v[0], t = v[1], s = v[2], B = L[0], A = L[1], z = L[2]; if (Math.abs(H - B) < o && Math.abs(F - A) < o && Math.abs(C - z) < o) { return c.identity(D) } y = H - B; x = F - A; w = C - z; E = 1 / Math.sqrt(y * y + x * x + w * w); y *= E; x *= E; w *= E; J = t * w - s * x; I = s * y - u * w; G = u * x - t * y; E = Math.sqrt(J * J + I * I + G * G); if (!E) { J = 0; I = 0; G = 0 } else { E = 1 / E; J *= E; I *= E; G *= E } r = x * G - w * I; q = w * J - y * G; p = y * I - x * J; E = Math.sqrt(r * r + q * q + p * p); if (!E) { r = 0; q = 0; p = 0 } else { E = 1 / E; r *= E; q *= E; p *= E } D[0] = J; D[1] = r; D[2] = y; D[3] = 0; D[4] = I; D[5] = q; D[6] = x; D[7] = 0; D[8] = G; D[9] = p; D[10] = w; D[11] = 0; D[12] = -(J * H + I * F + G * C); D[13] = -(r * H + q * F + p * C); D[14] = -(y * H + x * F + w * C); D[15] = 1; return D }; c.str = function (p) { return "mat4(" + p[0] + ", " + p[1] + ", " + p[2] + ", " + p[3] + ", " + p[4] + ", " + p[5] + ", " + p[6] + ", " + p[7] + ", " + p[8] + ", " + p[9] + ", " + p[10] + ", " + p[11] + ", " + p[12] + ", " + p[13] + ", " + p[14] + ", " + p[15] + ")" }; if (typeof (j) !== "undefined") { j.mat4 = c } var h = {}; h.create = function () { var p = new e(4); p[0] = 0; p[1] = 0; p[2] = 0; p[3] = 1; return p }; h.rotationTo = (function () { var p = l.create(); var q = l.fromValues(1, 0, 0); var r = l.fromValues(0, 1, 0); return function (v, t, s) { var u = l.dot(t, s); if (u < -0.999999) { l.cross(p, q, t); if (l.length(p) < 0.000001) { l.cross(p, r, t) } l.normalize(p, p); h.setAxisAngle(v, p, Math.PI); return v } else { if (u > 0.999999) { v[0] = 0; v[1] = 0; v[2] = 0; v[3] = 1; return v } else { l.cross(p, t, s); v[0] = p[0]; v[1] = p[1]; v[2] = p[2]; v[3] = 1 + u; return h.normalize(v, v) } } } })(); h.setAxes = (function () { var p = d.create(); return function (s, r, t, q) { p[0] = t[0]; p[3] = t[1]; p[6] = t[2]; p[1] = q[0]; p[4] = q[1]; p[7] = q[2]; p[2] = r[0]; p[5] = r[1]; p[8] = r[2]; return h.normalize(s, h.fromMat3(s, p)) } })(); h.clone = k.clone; h.fromValues = k.fromValues; h.copy = k.copy; h.set = k.set; h.identity = function (p) { p[0] = 0; p[1] = 0; p[2] = 0; p[3] = 1; return p }; h.setAxisAngle = function (q, t, p) { p = p * 0.5; var r = Math.sin(p); q[0] = r * t[0]; q[1] = r * t[1]; q[2] = r * t[2]; q[3] = Math.cos(p); return q }; h.add = k.add; h.multiply = function (r, x, w) { var p = x[0], z = x[1], y = x[2], q = x[3], u = w[0], t = w[1], s = w[2], v = w[3]; r[0] = p * v + q * u + z * s - y * t; r[1] = z * v + q * t + y * u - p * s; r[2] = y * v + q * s + p * t - z * u; r[3] = q * v - p * u - z * t - y * s; return r }; h.mul = h.multiply; h.scale = k.scale; h.rotateX = function (r, v, t) { t *= 0.5; var p = v[0], x = v[1], w = v[2], q = v[3], s = Math.sin(t), u = Math.cos(t); r[0] = p * u + q * s; r[1] = x * u + w * s; r[2] = w * u - x * s; r[3] = q * u - p * s; return r }; h.rotateY = function (r, v, t) { t *= 0.5; var p = v[0], x = v[1], w = v[2], q = v[3], s = Math.sin(t), u = Math.cos(t); r[0] = p * u - w * s; r[1] = x * u + q * s; r[2] = w * u + p * s; r[3] = q * u - x * s; return r }; h.rotateZ = function (r, v, t) { t *= 0.5; var p = v[0], x = v[1], w = v[2], q = v[3], s = Math.sin(t), u = Math.cos(t); r[0] = p * u + x * s; r[1] = x * u - p * s; r[2] = w * u + q * s; r[3] = q * u - w * s; return r }; h.calculateW = function (r, q) { var p = q[0], t = q[1], s = q[2]; r[0] = p; r[1] = t; r[2] = s; r[3] = -Math.sqrt(Math.abs(1 - p * p - t * t - s * s)); return r }; h.dot = k.dot; h.lerp = k.lerp; h.slerp = function (u, C, B, F) { var p = C[0], G = C[1], E = C[2], r = C[3], z = B[0], y = B[1], x = B[2], A = B[3]; var D, q, s, w, v; q = p * z + G * y + E * x + r * A; if (q < 0) { q = -q; z = -z; y = -y; x = -x; A = -A } if ((1 - q) > 0.000001) { D = Math.acos(q); s = Math.sin(D); w = Math.sin((1 - F) * D) / s; v = Math.sin(F * D) / s } else { w = 1 - F; v = F } u[0] = w * p + v * z; u[1] = w * G + v * y; u[2] = w * E + v * x; u[3] = w * r + v * A; return u }; h.invert = function (v, r) { var t = r[0], q = r[1], p = r[2], w = r[3], s = t * t + q * q + p * p + w * w, u = s ? 1 / s : 0; v[0] = -t * u; v[1] = -q * u; v[2] = -p * u; v[3] = w * u; return v }; h.conjugate = function (q, p) { q[0] = -p[0]; q[1] = -p[1]; q[2] = -p[2]; q[3] = p[3]; return q }; h.length = k.length; h.len = h.length; h.squaredLength = k.squaredLength; h.sqrLen = h.squaredLength; h.normalize = k.normalize; h.fromMat3 = (function () { var p = (typeof (Int8Array) !== "undefined" ? new Int8Array([1, 2, 0]) : [1, 2, 0]); return function (u, q) { var r = q[0] + q[4] + q[8]; var w; if (r > 0) { w = Math.sqrt(r + 1); u[3] = 0.5 * w; w = 0.5 / w; u[0] = (q[7] - q[5]) * w; u[1] = (q[2] - q[6]) * w; u[2] = (q[3] - q[1]) * w } else { var v = 0; if (q[4] > q[0]) { v = 1 } if (q[8] > q[v * 3 + v]) { v = 2 } var t = p[v]; var s = p[t]; w = Math.sqrt(q[v * 3 + v] - q[t * 3 + t] - q[s * 3 + s] + 1); u[v] = 0.5 * w; w = 0.5 / w; u[3] = (q[s * 3 + t] - q[t * 3 + s]) * w; u[t] = (q[t * 3 + v] + q[v * 3 + t]) * w; u[s] = (q[s * 3 + v] + q[v * 3 + s]) * w } return u } })(); h.str = function (p) { return "quat(" + p[0] + ", " + p[1] + ", " + p[2] + ", " + p[3] + ")" }; if (typeof (j) !== "undefined") { j.quat = h } })(a.exports) })(this); var RADIANS = Math.PI / 180; var PI = Math.PI; var TWOPI = Math.PI * 2; var ONEOPI = 1 / Math.PI; var PIO2 = Math.PI / 2; var EPSILON = 0.000001; glMatrix.setMatrixArrayType(Array); vec3.fromXYZ = function (a) { var b = new Array(3); b[0] = a.x; b[1] = a.y; b[2] = a.z; return b }; vec4.fromXYZ = function (b, a) { var c = new Array(4); c[0] = b.x; c[1] = b.y; c[2] = b.z; c[3] = a; return c }; if (typeof Phoria === "undefined" || !Phoria) { var Phoria = {} } (function () { Phoria.Util = {}; Phoria.Util.extend = function h(s, t, r) { var q = function () { }, p; q.prototype = t.prototype; s.prototype = new q(); s.prototype.constructor = s; s.superclass = t.prototype; if (t.prototype.constructor == Object.prototype.constructor) { t.prototype.constructor = t } if (r) { for (p in r) { if (r.hasOwnProperty(p)) { s.prototype[p] = r[p] } } } }; Phoria.Util.augment = function m(t, q) { for (var u in q.prototype) { if (typeof t.prototype[u] === "undefined") { t.prototype[u] = q.prototype[u] } } }; Phoria.Util.merge = function l(p, q) { var s = Array.isArray(q), r = s && [] || {}; if (s) { p = p || []; r = r.concat(p); q.forEach(function (u, t) { if (typeof u === "object") { r[t] = Phoria.Util.merge(p[t], u) } else { r[t] = u } }) } else { if (p && typeof p === "object") { Object.keys(p).forEach(function (t) { r[t] = p[t] }) } Object.keys(q).forEach(function (t) { if (typeof q[t] !== "object" || !q[t]) { r[t] = q[t] } else { if (!p[t]) { r[t] = q[t] } else { r[t] = Phoria.Util.merge(p[t], q[t]) } } }) } return r }; Phoria.Util.clone = function i(r) { var t = null, s = {}; for (var q in r) { t = r[q]; if (Array.isArray(t)) { s[q] = [].concat(t) } else { s[q] = t } } return s }; Phoria.Util.isIdentity = function d(p) { return (p[0] === 1 && p[1] === 0 && p[2] === 0 && p[3] === 0 && p[4] === 0 && p[5] === 1 && p[6] === 0 && p[7] === 0 && p[8] === 0 && p[9] === 0 && p[10] === 1 && p[11] === 0 && p[12] === 0 && p[13] === 0 && p[14] === 0 && p[15] === 1) }; Phoria.Util.calcNormalVector = function f(r, t, w, q, s, u) { var p = vec4.fromValues((t * u) - (w * s), -((u * r) - (q * w)), (r * s) - (t * q), 0); return vec4.normalize(p, p) }; Phoria.Util.thetaTo = function n(q, p) { return Math.acos(vec3.dot(q, p) / (Math.sqrt(q[0] * q[0] + q[1] * q[1] + q[2] * q[2]) * Math.sqrt(p[0] * p[0] + p[1] * p[1] + p[2] * p[2]))) }; Phoria.Util.averagePolyVertex = function e(s, u) { for (var t = 0, r = 0, q = 0, p = 0; t < s.length; t++) { r += u[s[t]][0]; q += u[s[t]][1]; p += u[s[t]][2] } return vec3.fromValues(r / s.length, q / s.length, p / s.length) }; Phoria.Util.averageObjectZ = function k(q) { var r = 0; for (var p = 0; p < q.length; p++) { r += q[p][3] } return r / q.length }; Phoria.Util.sortPolygons = function c(p, s) { for (var q = 0; q < p.length; q++) { p[q]._avz = 0 } var t; p.sort(function r(u, w) { if (u._avz === 0) { t = u.vertices; for (var v = 0; v < t.length; v++) { u._avz += s[t[v]][2] } u._avz = u._avz / t.length } if (w._avz === 0) { t = w.vertices; for (var v = 0; v < t.length; v++) { w._avz += s[t[v]][2] } w._avz = w._avz / t.length } return (u._avz < w._avz ? -1 : 1) }) }; Phoria.Util.sortEdges = function b(p, r) { for (var q = 0; q < p.length; q++) { p[q]._avz = 0 } p.sort(function s(t, u) { if (t._avz === 0) { t._avz = (r[t.a][2] + r[t.b][2]) * 0.5 } if (u._avz === 0) { u._avz = (r[u.a][2] + r[u.b][2]) * 0.5 } return (t._avz < u._avz ? -1 : 1) }) }; Phoria.Util.sortPoints = function j(q, r) { var p = function p(z, t, y, u) { var v = y, x = u, w, s; if (u > y) { w = t[(y + u) >> 1][2]; while (v <= x) { while (v < u && t[v][2] < w) { v++ } while (x > y && t[x][2] > w) { x-- } if (v <= x) { s = z[v]; z[v] = z[x]; z[x] = s; s = t[v]; t[v] = t[x]; t[x] = s; v++; x-- } } if (y < x) { p(z, t, y, x) } if (v < u) { p(z, t, v, u) } } }; p(r, q, 0, q.length - 1) }; Phoria.Util.generateTesselatedPlane = function g(D, q, p, s) { var E = [], u = [], A = [], r = s / q, w = s / D, z = 0; for (var v = 0, C, B = -s / 2; v <= D; v++) { C = -s / 2; for (var t = 0; t <= q; t++) { E.push({ x: C, y: 0, z: B }); if (t !== 0) { u.push({ a: z, b: z - 1 }) } if (v !== 0) { u.push({ a: z, b: z - q - 1 }) } if (v !== 0 && t !== 0) { A.push({ vertices: [z - q - 1, z - q - 2, z - 1, z] }) } C += r; z++ } B += w } return { points: E, edges: u, polygons: A } }; Phoria.Util.generateUnitCube = function o(q) { var p = q || 1; return { points: [{ x: -1 * p, y: 1 * p, z: -1 * p }, { x: 1 * p, y: 1 * p, z: -1 * p }, { x: 1 * p, y: -1 * p, z: -1 * p }, { x: -1 * p, y: -1 * p, z: -1 * p }, { x: -1 * p, y: 1 * p, z: 1 * p }, { x: 1 * p, y: 1 * p, z: 1 * p }, { x: 1 * p, y: -1 * p, z: 1 * p }, { x: -1 * p, y: -1 * p, z: 1 * p }], edges: [{ a: 0, b: 1 }, { a: 1, b: 2 }, { a: 2, b: 3 }, { a: 3, b: 0 }, { a: 4, b: 5 }, { a: 5, b: 6 }, { a: 6, b: 7 }, { a: 7, b: 4 }, { a: 0, b: 4 }, { a: 1, b: 5 }, { a: 2, b: 6 }, { a: 3, b: 7 }], polygons: [{ vertices: [0, 1, 2, 3] }, { vertices: [0, 4, 5, 1] }, { vertices: [1, 5, 6, 2] }, { vertices: [2, 6, 7, 3] }, { vertices: [4, 0, 3, 7] }, { vertices: [5, 4, 7, 6] }] } }; Phoria.Util.generateSphere = function a(K, H, D) { var G = [], r = [], p = []; for (var J = 0; J <= H; ++J) { for (var v = 0; v <= D; ++v) { var u = J * Math.PI / H; var q = v * 2 * Math.PI / D; var F = Math.sin(u); var E = Math.sin(q); var C = Math.cos(u); var s = Math.cos(q); var B = s * F; var A = C; var w = E * F; G.push({ x: K * B, y: K * A, z: K * w }) } } for (var J = 0; J < H; ++J) { for (var v = 0; v < D; ++v) { var t = (J * (D + 1)) + v; var I = t + D + 1; if (J === 0) { p.push({ vertices: [t + 1, I + 1, I] }); r.push({ a: t, b: I }) } else { if (J === H - 1) { p.push({ vertices: [t + 1, I, t] }); r.push({ a: t, b: I }) } else { p.push({ vertices: [t + 1, I + 1, I, t] }); r.push({ a: t, b: I }); r.push({ a: I, b: I + 1 }) } } } } return { points: G, edges: r, polygons: p } } })(); (function () { Phoria.Preloader = function () { this.images = []; return this }; Phoria.Preloader.prototype = { images: null, callback: null, counter: 0, addImage: function b(c, d) { var e = this; c.url = d; c.onload = function () { e.counter++; if (e.counter === e.images.length) { e.callback.call(e) } }; this.images.push(c) }, onLoadCallback: function a(e) { this.counter = 0; this.callback = e; for (var d = 0, c = this.images.length; d < c; d++) { this.images[d].src = this.images[d].url } } } })(); (function () { Phoria.Scene = function () { this.camera = { up: { x: 0, y: 1, z: 0 }, lookat: { x: 0, y: 0, z: 0 }, position: { x: 0, y: 0, z: -10 } }; this.perspective = { fov: 35, aspect: 1, near: 1, far: 1000 }; this.viewport = { x: 0, y: 0, width: 1024, height: 1024 }; this.graph = []; return this }; Phoria.Scene.create = function (d) { var c = new Phoria.Scene(); if (d) { if (d.camera) { c.camera = Phoria.Util.merge(c.camera, d.camera) } if (d.perspective) { c.perspective = Phoria.Util.merge(c.perspective, d.perspective) } if (d.viewport) { c.viewport = Phoria.Util.merge(c.viewport, d.viewport) } if (d.graph) { c.graph = d.graph } if (d.onCamera) { c.onCamera(d.onCamera) } } return c }; Phoria.Scene.prototype = { camera: null, perspective: null, graph: null, viewport: null, renderlist: null, lights: null, _lastTime: 0, onCameraHandlers: null, onCamera: function a(c) { if (this.onCameraHandlers === null) { this.onCameraHandlers = [] } this.onCameraHandlers.push(c) }, modelView: function b() { var c = Date.now(), g = (c - this._lastTime), m = g / (1000 / 60); g = g / m * 0.001; this._lastTime = c; var l = this.viewport.x, j = this.viewport.y, n = this.viewport.width * 0.5, e = this.viewport.height * 0.5; var o = mat4.create(); mat4.lookAt(o, vec3.fromValues(this.camera.position.x, this.camera.position.y, this.camera.position.z), vec3.fromValues(this.camera.lookat.x, this.camera.lookat.y, this.camera.lookat.z), vec3.fromValues(this.camera.up.x, this.camera.up.y, this.camera.up.z)); var f = mat4.create(); mat4.perspective(f, -this.perspective.fov * RADIANS, this.perspective.aspect, this.perspective.near, this.perspective.far); if (this.onCameraHandlers !== null) { for (var k in this.onCameraHandlers) { this.onCameraHandlers[k].call(this, o, f) } } var q = [], i = []; var d = function p(C, G) { for (var t = 0, z, D, x; t < C.length; t++) { z = C[t]; var u = z.matrix; if (G) { u = mat4.multiply(mat4.clone(u), u, G) } x = Phoria.Util.isIdentity(u); if (z.onSceneHandlers !== null) { for (var A in z.onSceneHandlers) { z.onSceneHandlers[A].call(z, this, u, g) } } if (z instanceof Phoria.BaseLight) { i.push(z) } else { if (z instanceof Phoria.Entity) { D = z.points.length; z.initCoordinateBuffers(); for (var J = 0, I, s; J < D; J++) { I = z.points[J]; s = vec4.set(z._worldcoords[J], I.x, I.y, I.z, 1); if (!x) { vec4.transformMat4(s, s, u) } } for (var J = 0; J < D; J++) { vec4.transformMat4(z._coords[J], z._worldcoords[J], o) } if (z.style.shademode === "lightsource") { switch (z.style.drawmode) { case "solid": Phoria.Util.sortPolygons(z.polygons, z._coords); break; case "wireframe": Phoria.Util.sortEdges(z.edges, z._coords); break; case "point": Phoria.Util.sortPoints(z._coords, z._worldcoords); break } } for (var J = 0; J < D; J++) { vec4.transformMat4(z._coords[J], z._coords[J], f) } var F = 0; for (var J = 0, s, H; J < D; J++) { s = z._coords[J]; H = s[3]; if (H === 0) { H = EPSILON } F += (z._clip[J] = (s[0] > H || s[0] < -H || s[1] > H || s[1] < -H || s[2] > H || s[2] < -H) ? 1 : 0); s[0] /= H; s[1] /= H; s[2] /= H; s[0] = n * s[0] + l + n; s[1] = e * s[1] + j + e } if (F !== D) { if (z.polygons.length !== 0) { var B = mat4.invert(mat4.clone(u), u); mat4.transpose(B, B); switch (z.style.shademode) { case "plain": case "lightsource": for (var y = 0, E, r; y < z.polygons.length; y++) { if (!z.polygons[y]._worldnormal) { z.polygons[y]._worldnormal = vec4.create() } E = z.polygons[y].normal; r = z.polygons[y]._worldnormal; vec4.transformMat4(r, E, B); vec4.normalize(r, r) } break; case "gouraud": for (var y = 0, E, r; y < D; y++) { E = z._vertexNormals[y]; r = z._worldVertexNormals[y]; vec4.transformMat4(r, E, B); vec4.normalize(r, r) } break } } q.push(z) } } } if (z.children && z.children.length !== 0) { d.call(this, z.children, u) } } }; d.call(this, this.graph); this.renderlist = q; this.lights = i } } })(); (function () { Phoria.BaseEntity = function () { this.matrix = mat4.create(); this.children = []; return this }; Phoria.BaseEntity.create = function (q, p) { if (!p) { p = new Phoria.BaseEntity() } if (q.matrix) { p.matrix = q.matrix } if (q.children) { p.children = q.children } if (q.onScene) { p.onScene(q.onScene) } return p }; Phoria.BaseEntity.prototype = { children: null, matrix: null, onSceneHandlers: null, onScene: function g(p) { if (this.onSceneHandlers === null) { this.onSceneHandlers = [] } this.onSceneHandlers.push(p) }, identity: function l() { mat4.identity(this.matrix); return this }, invert: function c() { mat4.invert(this.matrix, this.matrix); return this }, multiply: function d(p) { mat4.multiply(this.matrix, this.matrix, p); return this }, scale: function h(p) { mat4.scale(this.matrix, this.matrix, p); return this }, scaleN: function h(p) { mat4.scale(this.matrix, this.matrix, vec3.fromValues(p, p, p)); return this }, rotate: function i(p, q) { mat4.rotate(this.matrix, this.matrix, p, q); return this }, rotateX: function o(p) { mat4.rotateX(this.matrix, this.matrix, p); return this }, rotateY: function m(p) { mat4.rotateY(this.matrix, this.matrix, p); return this }, rotateZ: function k(p) { mat4.rotateZ(this.matrix, this.matrix, p); return this }, translate: function f(p) { mat4.translate(this.matrix, this.matrix, p); return this }, translateX: function e(p) { mat4.translate(this.matrix, this.matrix, vec3.fromValues(p, 0, 0)); return this }, translateY: function b(p) { mat4.translate(this.matrix, this.matrix, vec3.fromValues(0, p, 0)); return this }, translateZ: function a(p) { mat4.translate(this.matrix, this.matrix, vec3.fromValues(0, 0, p)); return this }, determinant: function n() { return mat4.determinant(this.matrix) }, transpose: function j() { mat4.transpose(this.matrix, this.matrix); return this } } })(); var CLIP_ARRAY_TYPE = (typeof Uint32Array !== "undefined") ? Uint32Array : Array; (function () { Phoria.Entity = function () { Phoria.Entity.superclass.constructor.call(this); this.points = []; this.edges = []; this.polygons = []; this.textures = []; this.style = { color: [128, 128, 128], specular: 0, drawmode: "solid", shademode: "lightsource", sortmode: "sorted", fillmode: "inflate", linewidth: 1, linescale: 0, hiddenangle: 0, doublesided: false }; return this }; Phoria.Entity.create = function (g, f) { if (!f) { f = new Phoria.Entity() } Phoria.BaseEntity.create(g, f); if (g.points) { f.points = g.points } if (g.polygons) { f.polygons = g.polygons } if (g.edges) { f.edges = g.edges } if (g.style) { f.style = Phoria.Util.merge(f.style, g.style) } f.generatePolygonNormals(); return f }; Phoria.Util.extend(Phoria.Entity, Phoria.BaseEntity, { points: null, edges: null, polygons: null, style: null, textures: null, _worldcoords: null, _coords: null, _vertexNormals: null, _worldVertexNormals: null, _clip: null, _averagez: 0, generatePolygonNormals: function c() { if (this.polygons) { var o = this.points, n = this.polygons; for (var j = 0, k, f, m, h, e, l, g; j < n.length; j++) { k = n[j].vertices; f = o[k[1]].x - o[k[0]].x; m = o[k[1]].y - o[k[0]].y; h = o[k[1]].z - o[k[0]].z; e = o[k[2]].x - o[k[0]].x; l = o[k[2]].y - o[k[0]].y; g = o[k[2]].z - o[k[0]].z; n[j].normal = Phoria.Util.calcNormalVector(f, m, h, e, l, g); if (n[j].texture === undefined) { n[j].texture = null } } } }, generateVertexNormals: function b() { if (this.polygons) { var s = this.points, q = this.polygons, o = new Array(s.length); for (var f = 0, r; f < q.length; f++) { r = q[f].vertices; for (var t = 0, e; t < r.length; t++) { e = o[r[t]] || []; e.push(f); o[r[t]] = e } } var g = new Array(s.length); for (var j = 0, n; j < o.length; j++) { n = o[j]; if (n) { for (var f = 0, l = 0, k = 0, h = 0, m; f < n.length; f++) { m = q[f].normal; l += m[0]; k += m[1]; h += m[2] } l /= n.length; k /= n.length; h /= n.length; g[j] = vec4.fromValues(l, k, h, 0) } } this._vertexNormals = g } }, initCoordinateBuffers: function d() { var e = this.points.length; if (this._worldcoords === null || this._worldcoords.length < e) { this._worldcoords = this.populateBuffer(e, function () { return vec4.create() }) } if (this._coords === null || this._coords.length < e) { this._coords = this.populateBuffer(e, function () { return vec4.create() }) } if (this._worldVertexNormals === null || this._worldVertexNormals.length < e) { this._worldVertexNormals = this.populateBuffer(e, function () { return vec4.create() }) } if (this._clip === null || this._clip.length < e) { this._clip = new CLIP_ARRAY_TYPE(e) } }, populateBuffer: function a(e, g) { var h = new Array(e); for (var f = 0; f < e; f++) { h[f] = g() } return h } }) })(); (function () { Phoria.PositionalAspect = {}; Phoria.PositionalAspect.prototype = { position: null, worldposition: null, updatePosition: function a(c) { var b = vec4.fromXYZ(this.position, 1); vec4.transformMat4(b, b, c); this.worldposition = b } } })(); (function () { Phoria.PhysicsEntity = function () { Phoria.PhysicsEntity.superclass.constructor.call(this); this.velocity = { x: 0, y: 0, z: 0 }; this.position = { x: 0, y: 0, z: 0 }; this._force = { x: 0, y: 0, z: 0 }; this._acceleration = null; this.gravity = true; this.onScene(this.applyPhysics); return this }; Phoria.PhysicsEntity.create = function (f) { var d = new Phoria.PhysicsEntity(); Phoria.Entity.create(f, d); if (f.velocity) { d.velocity = f.velocity } if (f.position) { d.position = f.position } if (f.force) { d._force = f.force } if (f.gravity) { d.gravity = f.gravity } return d }; Phoria.Util.extend(Phoria.PhysicsEntity, Phoria.Entity, { velocity: null, gravity: false, _force: null, _acceleration: null, impulse: function b(d) { this._acceleration = d }, force: function a(d) { this._force = d }, applyPhysics: function c(f, g, e) { this.updatePosition(g); var d = e * e; if (this._acceleration) { this.velocity.x += (this._acceleration.x * d); this.velocity.y += (this._acceleration.y * d); this.velocity.z += (this._acceleration.z * d); this._acceleration = null } if (this._force) { this.velocity.x += (this._force.x * d); this.velocity.y += (this._force.y * d); this.velocity.z += (this._force.z * d) } if (this.gravity) { this.velocity.x += (Phoria.PhysicsEntity.GRAVITY.x * d); this.velocity.y += (Phoria.PhysicsEntity.GRAVITY.y * d); this.velocity.z += (Phoria.PhysicsEntity.GRAVITY.z * d) } this.translate(vec3.fromXYZ(this.velocity)) } }); Phoria.Util.augment(Phoria.PhysicsEntity, Phoria.PositionalAspect) })(); Phoria.PhysicsEntity.GRAVITY = { x: 0, y: -9.8, z: 0 }; (function () { Phoria.EmitterEntity = function () { Phoria.EmitterEntity.superclass.constructor.call(this); this.position = { x: 0, y: 0, z: 0 }; this.positionRnd = { x: 0, y: 0, z: 0 }; this.velocity = { x: 0, y: 1, z: 0 }; this.velocityRnd = { x: 0, y: 0, z: 0 }; this.maximum = 1000; this.style = { color: [128, 128, 128], drawmode: "point", shademode: "plain", sortmode: "unsorted", linewidth: 5, linescale: 2 }; this._lastEmitTime = Date.now(); this.onScene(this.emitParticles); return this }; Phoria.EmitterEntity.create = function (d) { var c = new Phoria.EmitterEntity(); Phoria.BaseEntity.create(d, c); if (d.position) { c.position = d.position } if (d.positionRnd) { c.positionRnd = d.positionRnd } if (d.rate) { c.rate = d.rate } if (d.maximum) { c.maximum = d.maximum } if (d.velocity) { c.velocity = d.velocity } if (d.velocityRnd) { c.velocityRnd = d.velocityRnd } if (d.lifetime) { c.lifetime = d.lifetime } if (d.lifetimeRnd) { c.lifetimeRnd = d.lifetimeRnd } if (d.style) { c.style = Phoria.Util.merge(c.style, d.style) } if (d.onParticle) { c.onParticle(d.onParticle) } return c }; Phoria.Util.extend(Phoria.EmitterEntity, Phoria.BaseEntity, { style: null, rate: 0, maximum: 0, velocity: null, velocityRnd: null, lifetime: 0, lifetimeRnd: 0, _lastEmitTime: 0, onParticleHandlers: null, onParticle: function a(c) { if (this.onParticleHandlers === null) { this.onParticleHandlers = [] } this.onParticleHandlers.push(c) }, emitParticles: function b(l, f, g) { this.updatePosition(f); var e = Date.now(); for (var j = 0, d; j < this.children.length; j++) { d = this.children[j]; if (d._gravetime && e > d._gravetime) { this.children.splice(j, 1) } } var q = e - this._lastEmitTime; var n = Math.floor((this.rate / 1000) * q); if (n > 0) { for (var o = 0; o < n && (this.maximum === 0 || this.children.length < this.maximum) ; o++) { var r = { x: this.position.x, y: this.position.y, z: this.position.z }; r.x += (Math.random() * this.positionRnd.x) - (this.positionRnd.x * 0.5); r.y += (Math.random() * this.positionRnd.y) - (this.positionRnd.y * 0.5); r.z += (Math.random() * this.positionRnd.z) - (this.positionRnd.z * 0.5); var s = { x: this.velocity.x, y: this.velocity.y, z: this.velocity.z }; s.x += (Math.random() * this.velocityRnd.x) - (this.velocityRnd.x * 0.5); s.y += (Math.random() * this.velocityRnd.y) - (this.velocityRnd.y * 0.5); s.z += (Math.random() * this.velocityRnd.z) - (this.velocityRnd.z * 0.5); var m = new Phoria.PhysicsEntity(); m.points = [r]; m.velocity = s; m.style = this.style; m._gravetime = Math.floor(e + this.lifetime + (this.lifetimeRnd * Math.random()) - this.lifetimeRnd * 0.5); if (this.onParticleHandlers !== null) { for (var k in this.onParticleHandlers) { this.onParticleHandlers[k].call(this, m) } } this.children.push(m) } this._lastEmitTime = e } } }); Phoria.Util.augment(Phoria.EmitterEntity, Phoria.PositionalAspect) })(); (function () { Phoria.BaseLight = function () { Phoria.BaseLight.superclass.constructor.call(this); this.color = [1, 1, 1]; this.intensity = 1; return this }; Phoria.Util.extend(Phoria.BaseLight, Phoria.BaseEntity, { color: null, intensity: 0 }) })(); (function () { Phoria.DistantLight = function () { Phoria.DistantLight.superclass.constructor.call(this); this.direction = { x: 0, y: 0, z: 1 }; this.onScene(this.transformToScene); return this }; Phoria.DistantLight.create = function (c) { var b = new Phoria.DistantLight(); Phoria.BaseEntity.create(c, b); if (c.color) { b.color = c.color } if (c.intensity) { b.intensity = c.intensity } if (c.direction) { b.direction = c.direction } return b }; Phoria.Util.extend(Phoria.DistantLight, Phoria.BaseLight, { direction: null, worlddirection: null, transformToScene: function a(c, d, b) { this.worlddirection = vec3.fromValues(-this.direction.x, -this.direction.y, -this.direction.z) } }) })(); (function () { Phoria.PointLight = function () { Phoria.PointLight.superclass.constructor.call(this); this.position = { x: 0, y: 0, z: -1 }; this.attenuation = 0.1; this.attenuationFactor = "linear"; this.onScene(this.transformToScene); return this }; Phoria.PointLight.create = function (c) { var b = new Phoria.PointLight(); Phoria.BaseEntity.create(c, b); if (c.color) { b.color = c.color } if (c.intensity) { b.intensity = c.intensity } if (c.position) { b.position = c.position } if (c.attenuation) { b.attenuation = c.attenuation } if (c.attenuationFactor) { b.attenuationFactor = c.attenuationFactor } return b }; Phoria.Util.extend(Phoria.PointLight, Phoria.BaseLight, { attenuation: 0, attenuationFactor: null, transformToScene: function a(c, d, b) { this.updatePosition(d) } }); Phoria.Util.augment(Phoria.PointLight, Phoria.PositionalAspect) })(); (function () { Phoria.Renderer = function () { }; Phoria.Renderer.prototype = { sort: true, sortObjects: function b(g) { if (this.sort) { for (var h = 0; h < g.renderlist.length; h++) { g.renderlist[h]._averagez = 0 } g.renderlist.sort(function f(j, i) { if (j.style.sortmode === "sorted" && i.style.sortmode === "sorted") { if (j._averagez === 0) { j._averagez = Phoria.Util.averageObjectZ(j._coords) } if (i._averagez === 0) { i._averagez = Phoria.Util.averageObjectZ(i._coords) } return (j._averagez < i._averagez ? 1 : -1) } else { return (j.style.sortmode === "sorted" ? 1 : -1) } }) } }, calcNormalBrightness: function d(k, m, i) { var o = [0, 0, 0]; for (var n = 0, j, p; n < i.length; n++) { j = i[n]; if (j instanceof Phoria.DistantLight) { p = vec3.dot(m, j.worlddirection) * j.intensity } else { if (j instanceof Phoria.PointLight) { var g = vec3.subtract(vec3.create(), k, j.worldposition), f = vec3.length(g), l; vec3.normalize(g, g); var h = vec3.dot(m, vec3.negate(g, g)); if (h <= 0) { continue } switch (j.attenuationFactor) { default: case "none": l = j.attenuation; break; case "linear": l = j.attenuation * f; break; case "squared": l = j.attenuation * f * f; break } p = h * j.intensity / l } } o[0] += p * j.color[0]; o[1] += p * j.color[1]; o[2] += p * j.color[2] } return o }, calcPositionBrightness: function a(j, h) { var m = [0, 0, 0]; for (var l = 0, i, n; l < h.length; l++) { i = h[l]; if (i instanceof Phoria.DistantLight) { n = i.intensity } else { if (i instanceof Phoria.PointLight) { var g = vec3.subtract(vec3.create(), j, i.worldposition), f = vec3.length(g), k; vec3.normalize(g, g); switch (i.attenuationFactor) { case "linear": k = i.attenuation * f; break; case "squared": k = i.attenuation * f * f; break; default: case "none": k = i.attenuation; break } n = i.intensity / (k * 2) } } m[0] += n * i.color[0]; m[1] += n * i.color[1]; m[2] += n * i.color[2] } return m }, inflatePolygon: function c(o, r) { var q = [], k = new Array(o.length); for (var m = 0, l = o.length, g, s, f, p, u, t, n; m < l; m++) { g = r[o[m]][0]; s = r[o[m]][1]; if (m < l - 1) { f = r[o[m + 1]][0]; p = r[o[m + 1]][1] } else { f = r[o[0]][0]; p = r[o[0]][1] } u = p - s; t = -(f - g); n = Math.sqrt(u * u + t * t); u /= n; t /= n; u *= 0.5; t *= 0.5; q.push({ x: g + u, y: s + t }); q.push({ x: f + u, y: p + t }) } for (var m = 0, l = o.length, h; m < l; m++) { if (m === 0) { h = this.intersection(q[(l - 1) * 2], q[(l - 1) * 2 + 1], q[0], q[1]) } else { h = this.intersection(q[(m - 1) * 2], q[(m - 1) * 2 + 1], q[m * 2], q[m * 2 + 1]) } if (Math.abs(h[0] - r[o[m]][0]) > 1.5 || Math.abs(h[1] - r[o[m]][1]) > 1.5) { h[0] = r[o[m]][0]; h[1] = r[o[m]][1] } k[m] = h } return k }, intersection: function e(i, h, m, l) { var g = h.x - i.x, o = m.x - l.x, k = m.x - i.x, f = h.y - i.y, n = m.y - l.y, j = m.y - i.y, p = (o * j - n * k) / (f * o - g * n); return [i.x + p * (h.x - i.x), i.y + p * (h.y - i.y)] } } })(); (function () { Phoria.CanvasRenderer = function (e) { Phoria.CanvasRenderer.superclass.constructor.call(this); this.canvas = e; this.ctx = e.getContext("2d"); return this }; Phoria.Util.extend(Phoria.CanvasRenderer, Phoria.Renderer, { canvas: null, ctx: null, render: function c(k, m) { this.sortObjects(k); var f = this.ctx; if (!m) { f.clearRect(0, 0, canvas.width, canvas.height) } else { m.call(this, f) } for (var l = 0, j; l < k.renderlist.length; l++) { j = k.renderlist[l]; f.save(); if (j.style.compositeOperation) { f.globalCompositeOperation = j.style.compositeOperation } switch (j.style.drawmode) { case "solid": if (j.style.fillmode === "fillstroke" || j.style.fillmode === "hiddenline") { f.lineWidth = 1 } var e = vec3.fromValues(k.camera.position.x, k.camera.position.y, k.camera.position.z); for (var g = 0; g < j.polygons.length; g++) { this.renderPolygon(f, j, j.polygons[g], e, k.lights) } break; case "wireframe": f.lineWidth = j.style.linewidth; if (j.style.shademode === "plain") { f.strokeStyle = "rgb(" + j.style.color[0] + "," + j.style.color[1] + "," + j.style.color[2] + ")"; f.beginPath(); for (var g = 0; g < j.edges.length; g++) { this.renderEdge(f, j, j.edges[g], k.lights) } f.closePath(); f.stroke() } else { for (var g = 0; g < j.edges.length; g++) { this.renderEdge(f, j, j.edges[g], k.lights) } } break; case "point": var h = j._coords; if (j.style.shademode === "plain") { f.fillStyle = "rgb(" + j.style.color[0] + "," + j.style.color[1] + "," + j.style.color[2] + ")" } for (var g = 0; g < h.length; g++) { this.renderPoint(f, j, h[g], g, k.lights) } } f.restore() } }, renderPoint: function a(f, j, k, i, h) { if (j._clip[i]) { return } var e = j.style.linewidth; if (j.style.linescale !== 0) { e = (j.style.linewidth * j.style.linescale) / ((j._coords[i][3]) / 16) } switch (j.style.shademode) { case "plain": f.beginPath(); f.arc(k[0], k[1], e, 0, TWOPI, true); f.closePath(); f.fill(); break; case "sprite": if (j.style.sprite) { f.drawImage(j.style.sprite, k[0] - e, k[1] - e, e + e, e + e) } break; case "lightsource": var g = this.calcPositionBrightness(j._worldcoords[i], h); f.fillStyle = "rgb(" + Math.min(Math.ceil(g[0] * j.style.color[0]), 255) + "," + Math.min(Math.ceil(g[1] * j.style.color[1]), 255) + "," + Math.min(Math.ceil(g[2] * j.style.color[2]), 255) + ")"; f.beginPath(); f.arc(k[0], k[1], e, 0, TWOPI, true); f.closePath(); f.fill(); break } }, renderEdge: function d(m, i, g, h) { if (i._clip[g.a] & i._clip[g.b]) { return } var l = i._coords; if (i.style.linescale !== 0) { m.lineWidth = (i.style.linewidth * i.style.linescale) / (((i._coords[g.a][3] + i._coords[g.b][3]) * 0.5) / 32) } if (i.style.shademode === "lightsource") { var f = i._worldcoords[g.a], e = i._worldcoords[g.b], j = vec3.fromValues((f[0] + e[0]) * 0.5, (f[1] + e[1]) * 0.5, (f[2] + e[2]) * 0.5); var k = this.calcPositionBrightness(j, h); m.beginPath(); m.strokeStyle = "rgb(" + Math.min(Math.ceil(k[0] * i.style.color[0]), 255) + "," + Math.min(Math.ceil(k[1] * i.style.color[1]), 255) + "," + Math.min(Math.ceil(k[2] * i.style.color[2]), 255) + ")"; m.moveTo(l[g.a][0], l[g.a][1]); m.lineTo(l[g.b][0], l[g.b][1]); m.closePath(); m.stroke() } else { m.moveTo(l[g.a][0], l[g.a][1]); m.lineTo(l[g.b][0], l[g.b][1]) } }, renderPolygon: function b(p, m, g, z, x) { var t = m._coords, w = m._clip, k = g.vertices, r = g.color ? g.color : m.style.color, h = null, e; var q = 1; for (var u = 0; u < k.length; u++) { q &= w[k[u]] } if (q) { return } if (!m.style.doublesided && vec3.dot(z, g._worldnormal) < m.style.hiddenangle) { return } switch (m.style.shademode) { case "plain": if (g.texture === null) { h = r[0] + "," + r[1] + "," + r[2] } break; case "lightsource": var e = this.calcNormalBrightness(Phoria.Util.averagePolyVertex(k, m._worldcoords), g._worldnormal, x); h = Math.min(Math.ceil(e[0] * r[0]), 255) + "," + Math.min(Math.ceil(e[1] * r[1]), 255) + "," + Math.min(Math.ceil(e[2] * r[2]), 255); break } p.save(); if (g.texture !== null) { var y = m.textures[g.texture]; var o = function (K, H, P, G, N, F, L) { p.beginPath(); p.moveTo(K[0][0], K[0][1]); for (var O = 1, M = K.length; O < M; O++) { p.lineTo(K[O][0], K[O][1]) } p.closePath(); p.clip(); var S = K[0][0], C = K[0][1], R = K[1][0], B = K[1][1], Q = K[2][0], A = K[2][1]; var v = v = 1 / (H * (L - N) - G * L + F * N + (G - F) * P); var U = -(P * (Q - R) - N * Q + L * R + (N - L) * S) * v, T = (N * A + P * (B - A) - L * B + (L - N) * C) * v, E = (H * (Q - R) - G * Q + F * R + (G - F) * S) * v, D = -(G * A + H * (B - A) - F * B + (F - G) * C) * v, J = (H * (L * R - N * Q) + P * (G * Q - F * R) + (F * N - G * L) * S) * v, I = (H * (L * B - N * A) + P * (G * A - F * B) + (F * N - G * L) * C) * v; p.transform(U, T, E, D, J, I); p.drawImage(y, 0, 0) }; if (h !== null) { var f = e[0] * 0.3 + e[1] * 0.6 + e[2] * 0.1; if (f > 1) { f = 1 } p.fillStyle = "rgba(" + h + "," + (1 - f).toFixed(3) + ")" } var n = this.inflatePolygon(k, t); if (k.length === 3) { o.call(this, n, 0, 0, y.width, 0, y.width, y.height); if (h !== null) { p.fill() } } else { if (k.length === 4) { p.save(); o.call(this, n.slice(0, 3), 0, 0, y.width, 0, y.width, y.height); p.restore(); var l = new Array(3); l[0] = n[2]; l[1] = n[3]; l[2] = n[0]; p.save(); o.call(this, l, y.width, y.height, 0, y.height, 0, 0); p.restore(); if (h !== null) { p.beginPath(); p.moveTo(n[0][0], n[0][1]); for (var u = 1, s = n.length; u < s; u++) { p.lineTo(n[u][0], n[u][1]) } p.closePath(); p.fill() } } } } else { if (m.style.fillmode === "inflate") { var n = this.inflatePolygon(k, t); p.beginPath(); p.moveTo(n[0][0], n[0][1]); for (var u = 1, s = k.length; u < s; u++) { p.lineTo(n[u][0], n[u][1]) } p.closePath() } else { p.beginPath(); p.moveTo(t[k[0]][0], t[k[0]][1]); for (var u = 1; u < k.length; u++) { p.lineTo(t[k[u]][0], t[k[u]][1]) } p.closePath() } h = "rgb(" + h + ")"; switch (m.style.fillmode) { case "fill": p.fillStyle = h; p.fill(); break; case "filltwice": p.fillStyle = h; p.fill(); p.fill(); break; case "inflate": p.fillStyle = h; p.fill(); break; case "fillstroke": p.fillStyle = h; p.fill(); p.strokeStyle = h; p.stroke(); break; case "hiddenline": p.strokeStyle = h; p.stroke(); break } } p.restore() } }) })(); (function () { Phoria.SoftwareRenderer = function (e) { Phoria.SoftwareRenderer.superclass.constructor.call(this); this.canvas = e; this.ctx = e.getContext("2d"); this._imagedata = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height); this._data = this._imagedata.data; return this }; Phoria.Util.extend(Phoria.SoftwareRenderer, Phoria.Renderer, { canvas: null, ctx: null, _imagedata: null, _data: null, render: function c(j) { this.sortObjects(j); this.clearCanvasRect(0, 0, this.canvas.width, this.canvas.height); for (var k = 0, h; k < j.renderlist.length; k++) { h = j.renderlist[k]; switch (h.style.drawmode) { case "solid": var e = vec3.fromValues(j.camera.position.x, j.camera.position.y, j.camera.position.z); var f = 0; for (var g = 0; g < h.polygons.length; g++) { if (this.renderPolygon(null, h, h.polygons[g], e, j.lights)) { f++ } } break } } this.ctx.putImageData(this._imagedata, 0, 0, 0, 0, this.canvas.width, this.canvas.height) }, clearCanvasRect: function b(e, m, i, f) { var g = (e + m * this.canvas.width - 1) * 4 + 3, k = (this.canvas.width - (i - e)) * 4, h = this._data; for (var j = m; j < f; j++) { for (var l = e; l < i; l++) { h[g += 4] = 0 } g += k } }, renderPolygon: function a(q, l, e, m, j) { var p = l._coords, f = l._clip, n = e.vertices, g = e.color ? e.color : l.style.color; var h = 1; for (var k = 0; k < n.length; k++) { h &= f[n[k]] } if (h) { return false } if (!l.style.doublesided && vec3.dot(m, e._worldnormal) < l.style.hiddenangle) { return false } var o; switch (l.style.shademode) { case "plain": o = new Array(3); o[0] = g[0]; o[1] = g[1]; o[2] = g[2]; break; case "lightsource": o = this.calcNormalBrightness(Phoria.Util.averagePolyVertex(n, l._worldcoords), e._worldnormal, j); o[0] = Math.ceil(Math.min(o[0] * g[0], 255)); o[1] = Math.ceil(Math.min(o[1] * g[1], 255)); o[2] = Math.ceil(Math.min(o[2] * g[2], 255)); break } this.drawTriangle(p[n[2]][0], p[n[2]][1], p[n[1]][0], p[n[1]][1], p[n[0]][0], p[n[0]][1], o[0], o[1], o[2]); if (n.length === 4) { this.drawTriangle(p[n[0]][0], p[n[0]][1], p[n[3]][0], p[n[3]][1], p[n[2]][0], p[n[2]][1], o[0], o[1], o[2]) } return true }, drawTriangle: function d(s, V, q, T, o, S, I, O, Q) { var s = Math.round(16 * s), q = Math.round(16 * q), o = Math.round(16 * o), V = Math.round(16 * V), T = Math.round(16 * T), S = Math.round(16 * S); var C = s - q, p = q - o, U = o - s, w = V - T, k = T - S, N = S - V; var E = C << 4, t = p << 4, e = U << 4, A = w << 4, n = k << 4, R = N << 4; var L = this.canvas.width, m = this.canvas.height, P = this._data; var l = Math.max((Math.min(s, q, o) + 15) >> 4, 0), F = Math.min((Math.max(s, q, o) + 15) >> 4, L), B = Math.max((Math.min(V, T, S) + 15) >> 4, 0), f = Math.min((Math.max(V, T, S) + 15) >> 4, m); if (F <= l || f <= B) { return } var j = w * s - C * V, i = k * q - p * T, h = N * o - U * S; if (w < 0 || (w == 0 && C > 0)) { j++ } if (k < 0 || (k == 0 && p > 0)) { i++ } if (N < 0 || (N == 0 && U > 0)) { h++ } var z = j + C * (B << 4) - w * (l << 4), v = i + p * (B << 4) - k * (l << 4), u = h + U * (B << 4) - N * (l << 4), M, K, J; for (var D = B, G, H; D < f; D++) { M = z; K = v; J = u; for (G = l; G < F; G++) { if (M > 0 && K > 0 && J > 0) { H = (G + D * L) << 2; P[H] = I; P[H + 1] = O; P[H + 2] = Q; P[H + 3] = 255 } M -= A; K -= n; J -= R } z += E; v += t; u += e } } }) })();